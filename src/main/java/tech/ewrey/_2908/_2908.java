package tech.ewrey._2908;

public class _2908 {

    public static void main(String[] args) {
        System.out.println(minimumSum(new int[]{8,6,1,5,3}));
        System.out.println(minimumSum(new int[]{5,4,8,7,10,2}));
        System.out.println(minimumSum(new int[]{6,5,4,3,4,5}));
    }

    /*
        1,2,3 - n = 5
        1,2,4
        1,2,5
        -----
        1,3,4
        1,3,5
        -----
        1,4,5
        -----
        2,3,4
        2,3,5
        -----
        2,4,5
        -----
        3,4,5
        END
     */
    /*
        Когда последнее число (3) становится == n (5), например 1,2,5
        Необходимо выполнить алгоритм нахождения другого подходящего под условия числа, а именно:
        1 < 2 < 3
        В нашем случае это 1,3,4 НО как его найти?
        Строго каждое левое число ориентируется на правое, оно должно быть его меньше, или диапазон чисел исчерпан
        Так же есть некий паттерн, например для 3 числа подходящие числа от 2 до 5, 1 никогда там не будет, поскольку
            минимальная структура это 0, 1, 2

        Для 2 числа соответственно от 1 до 4, поскольку максимальный возможный паттерн это 3,4,5 выше этого ничего не
            может быть
        Имеем: важно знать максимум и минимум, минимум всегда 0, 1, 2; Максимум n - 2, n - 1, n
        Получается если 3 число == n, мы должны проверить предыдущее на предмет не выходит ли оно за рамки и если
            выходит то конец или проверка прошлого числа если такое существует

        1,2,5 Проверяем 2 число, оно == 2, если к нему прибавить 1, то получится 3, оно меньше чем n - 1, строгая формула
            _2 + 1 < n - 1
            Если ок, то меняем на _2 + 1, и _3 тоже проверяем на _2 + 1 < n, если и тут ок то просто делаем
                _2 = _2 + 1 и _3 = _2 + 1
        1, 3, 4
     */

    public static int minimumSum(int[] nums) {
        int[] tmp = new int[4];
        int min = Integer.MAX_VALUE;
        boolean b = false;
        for (int n = nums.length - 1, _1 = 0, _2 = _1 + 1, _3 = _2 + 1; _3 <= n || _2 + 1 <= n - 1 || _1 + 1 <= n - 2;) {
            if (nums[_1] < nums[_2] && nums[_3] < nums[_2]) {
                min = Math.min(min, nums[_1] + nums[_2] + nums[_3]);
                b = true;
            }
            if (_3 + 1 <= n) _3++;
            else if (_2 + 1 <= n - 1 && _2 + 2 <= n) {
                _2++;
                _3 = _2 + 1;
            } else {
                _1++;
                _2 = _1 + 1;
                _3 = _2 + 1;
            }
        }
        return b ? min : -1;
    }

}
